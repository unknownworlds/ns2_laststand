// ======= Copyright (c) 2003-2011, Unknown Worlds Entertainment, Inc. All rights reserved. =======
//
// lua\Infestation.lua
//
//    Created by:   Andreas Urwalek (andi@unknownworlds.com)
//
//    Patch of infestation generated by hives or cysts.
//
// ========= For more information, visit us at http://www.unknownworlds.com =====================

Shared.PrecacheSurfaceShader("materials/infestation/infestation_decal.surface_shader")
Shared.PrecacheSurfaceShader("materials/infestation/infestation_shell.surface_shader")
Shared.PrecacheSurfaceShader("materials/infestation/Infestation.surface_shader")

Script.Load("lua/InfestationCache.lua")

local gInfestation = {}
local gDirtyTable = {}
local gInfestationQuality = nil

class 'Infestation'

local kMaxRadius = kInfestationRadius

function CreateStructureInfestation(parent, coords, teamNumber, infestationRadius, blobMultiplier)

    local infestation = Infestation()
    infestation:Initialize()
    infestation:SetCoords(coords)    
    infestation:SetMaxRadius(infestationRadius)
    infestation:SetBlobMultiplier(blobMultiplier)
    
    return infestation
    
end

local function DestroyClientGeometry(self)

    if self.infestationModelArray ~= nil then
        Client.DestroyRenderModelArray(self.infestationModelArray)
        self.infestationModelArray = nil
    end

    if self.infestationShellModelArray ~= nil then
        Client.DestroyRenderModelArray(self.infestationShellModelArray)
        self.infestationShellModelArray = nil
    end
    
    if self.infestationDecals ~= nil then
        for i=1,#self.infestationDecals do
            Client.DestroyRenderDecal(self.infestationDecals[i])
        end
        self.infestationDecals = nil
    end
  
    self.hasClientGeometry = false

end


function CreateInfestationModelArray(modelName, blobCoords, origin, radiusScale, radiusScale2 )

    local modelArray = nil
    
    if #blobCoords > 0 then
            
        local coordsArray = { }
        local numModels = 0
        
        for index, coords in ipairs(blobCoords) do

            local c  = Coords()
            c.xAxis  = coords.xAxis  * radiusScale
            c.yAxis  = coords.yAxis  * radiusScale2
            c.zAxis  = coords.zAxis  * radiusScale
            c.origin = coords.origin - coords.yAxis * 0.3
            
            numModels = numModels + 1
            coordsArray[numModels] = c
            
        end
        
        if numModels > 0 then

            modelArray = Client.CreateRenderModelArray(RenderScene.Zone_Default, numModels)
            modelArray:SetCastsShadows(false)
            modelArray:InstanceMaterials()

            modelArray:SetModel(modelName)
            modelArray:SetModels( coordsArray )

        end
        
    end
    
    return modelArray

end

function CreateModelArrays(self)
    
    // Make blobs on the ground thinner to so that Skulks and buildings aren't
    // obscured.
    local scale = 1
    if self.coords.yAxis.y > 0.5 then
        scale = 0.75
    end
    
    local origin = self.coords.origin

    self.infestationModelArray = CreateInfestationModelArray( "models/alien/infestation/infestation_blob.model", self.blobCoords, origin, 1, 1 * scale )
    self.infestationShellModelArray = CreateInfestationModelArray( "models/alien/infestation/infestation_shell.model", self.blobCoords, origin, 1.75, 1.25 * scale )
    
end

local function CreateDecals(self)

    local decals = { }
    
    for index, coords in ipairs(self.blobCoords) do

        local decal = Client.CreateRenderDecal()
        decal:SetMaterial(self.infestationMaterial)
        decal:SetCoords(coords)
        decal:SetExtents(Vector(1.5, 0.1, 1.5))
        decals[index] = decal
        
    end

    self.infestationDecals = decals

end

local function CreateClientGeometry(self)

    if gInfestationQuality == "rich" then
        CreateModelArrays(self)
    else
        CreateDecals(self)
    end
    
    self.qualityLoaded = gInfestationQuality
    self.hasClientGeometry = true
    
end

function Infestation:Initialize()

    self.radius = 0
    self.lastRadius = 0
    self.cloakFraction = 0
    self.lastCloakFraction = 0
    self.visible = false
    self.blobMultiplier = 1
    
    self.maxRadius = kMaxRadius
    self.blobCoords = {}
    
    if Client then
    
        self.infestationMaterial = Client.CreateRenderMaterial()
        self.infestationMaterial:SetMaterial("materials/infestation/infestation_decal.material")
    
    end
    
    self.destroyed = false
    
    table.insertunique(gDirtyTable, self)
    table.insert(gInfestation, self)
 
end

function Infestation:Uninitialize()

    if Client then
    
        DestroyClientGeometry(self)
    
        if self.infestationMaterial then
        
            Client.DestroyRenderMaterial(self.infestationMaterial)
            self.infestationMaterial = nil
        
        end
        
        self.destroyed = true
    
    end
    
    table.removevalue(gInfestation, self)
    
end

function Infestation:SetBlobMultiplier(multiplier)
    self.blobMultiplier = multiplier
end

function Infestation:SetIsVisible(visible)

    if self.visible ~= visible then
        
        table.insertunique(gDirtyTable, self)
        self.visible = visible
        
    end

end

function Infestation:GetIsVisible()
    return self.visible
end

function Infestation:SetCoords(coords)
    self.coords = Coords(coords)
    table.insertunique(gDirtyTable, self)
end

function Infestation:GetCoords()
    return self.coords
end

function Infestation:GetRadius()    
    return self.radius    
end

function Infestation:SetRadius(radius)

    if self.radius ~= radius then

        self.radius = radius
        table.insertunique(gDirtyTable, self)
    
    end
    
end

function Infestation:SetCloakFraction(cloakFraction)

    if self.cloakFraction ~= cloakFraction then
        
        self.cloakFraction = cloakFraction
        
        // this change is not interesting for the server
        if Client then
            table.insertunique(gDirtyTable, self)
        end
    
    end

end

function Infestation:SetMaxRadius(radius)
    self.maxRadius = radius
end

function Infestation:GetMaxRadius()
    return self.maxRadius
end

function Infestation:GenerateBlobs()

    assert(self.coords)
    
    // generate the blobs, use cached blobs if exist
    table.copy(gInfestationCache:GetBlobCoords(self), self.blobCoords)
    
end

local function SetMaterialParameters(modelArray, radiusFraction, origin, maxRadius)

    modelArray:SetMaterialParameter("amount", radiusFraction)
    modelArray:SetMaterialParameter("origin", origin)
    modelArray:SetMaterialParameter("maxRadius", maxRadius)

end


// only called when the infestation actually changed
function Infestation:RenderInfestation(generateBlobs)

    PROFILE("Infestation:RenderInfestation")
    
    if #self.blobCoords == 0 then
    
        if generateBlobs then
            self:GenerateBlobs()
        else
            return false
        end
    
    end
    
    local qualityChanged = self.qualityLoaded ~= gInfestationQuality
    
    if qualityChanged then
        DestroyClientGeometry(self)
    end

    if not self.hasClientGeometry and self.visible then
        CreateClientGeometry(self)
    elseif self.hasClientGeometry and not self.visible then
        DestroyClientGeometry(self)
    end

    local origin = self.coords.origin
    local amount = self.maxRadius > 0 and self.radius / self.maxRadius or 0
    
    // Apply cloaking effects.
    amount = amount * (1 - self.cloakFraction)
    
    if self.infestationModelArray then
    
        SetMaterialParameters(self.infestationModelArray, amount, origin, self.maxRadius)
        SetMaterialParameters(self.infestationShellModelArray, amount, origin, self.maxRadius)
        
    end
    
    if self.infestationDecals then
    
        self.infestationMaterial:SetParameter("amount", amount)
        self.infestationMaterial:SetParameter("origin", origin)
        self.infestationMaterial:SetParameter("maxRadius", self.maxRadius)
        
    end

end

// only called when the infestation actually changed
function Infestation:UpdateInfestables()

    PROFILE("Infestation:UpdateInfestables")

    local entityIds = {}
    local smallestRadius = self.radius
    local biggestRadius = self.lastRadius
    // point is guaranteed on infestation when growing, only shrinking requires another check
    local onInfestation = self.radius > self.lastRadius

    if smallestRadius > biggestRadius then
        smallestRadius, biggestRadius = biggestRadius, smallestRadius
    end
    
    local origin = self.coords.origin
    for index, entity in ipairs(GetEntitiesWithMixinWithinRange("InfestationTracker", self.coords.origin, biggestRadius)) do
    
        local range = (origin - entity:GetOrigin()):GetLength()
        if range >= smallestRadius and range <= biggestRadius then
            entity:UpdateInfestedState(onInfestation)
        end
        
    end

end

function Infestation:GetIsPointOnInfestation(point)

    local onInfestation = false
    
    // Check radius
    local radius = point:GetDistanceTo(self.coords.origin)
    if radius <= self:GetRadius() then
    
        // Check dot product
        local toPoint = point - self.coords.origin
        local verticalProjection = math.abs( self.coords.yAxis:DotProduct( toPoint ) )
        
        onInfestation = (verticalProjection < 1)
        
    end
    
    return onInfestation
   
end

local kUpdatesPerFrame = 1
local function UpdateDirtyTableClient()

    PROFILE("Infestation:UpdateDirtyTableClient")
    
    //DebugPrint("num infestation %s, num dirty %s", ToString(#gInfestation), ToString(#gDirtyTable))

    local remainingUpdates = {}
    local updatesDone = 0
    
    for i = 1, #gDirtyTable do
    
        local infestation = gDirtyTable[i]

        if not infestation.destroyed then
        
            infestation:RenderInfestation(updatesDone < kUpdatesPerFrame)
            if updatesDone >= kUpdatesPerFrame then
                // update later to prevent hitches
                table.insert(remainingUpdates, infestation)            
            else
            
                infestation.lastRadius = infestation.radius
                infestation.lastCloakFraction = infestation.cloakFraction
                
                updatesDone = updatesDone + 1
                
            end    
        
        end
    
    end
    
    gDirtyTable = remainingUpdates
    
end

local function UpdateDirtyTable()

    PROFILE("Infestation:UpdateDirtyTable")
    
    for i = 1, #gDirtyTable do
    
        local infestation = gDirtyTable[i]
    
        if not infestation.destroyed then
        
            infestation:UpdateInfestables()
            
            infestation.lastRadius = infestation.radius
            infestation.lastCloakFraction = infestation.cloakFraction
        
        end
    
    end
    
    gDirtyTable = {}

end

if Server then
    Event.Hook("UpdateServer", UpdateDirtyTable)
elseif Client then

    Event.Hook("UpdateClient", UpdateDirtyTableClient)

    function Infestation_SyncOptions()
    
        gInfestationQuality = Client.GetOptionString("graphics/infestation", "rich")
        Client.SetRenderSetting("infestation", gInfestationQuality)
        // mark all as dirty to update quality
        table.copy(gInfestation, gDirtyTable)
        
    end

    local function OnLoadComplete()
        if Client then
            Infestation_SyncOptions()
        end
    end
    
    Event.Hook("LoadComplete", OnLoadComplete)
    
    function Infestation_UpdateForPlayer()
        
        // Maximum number of blobs to generate in a frame.
        _numBlobsToGenerate = kBlobGenMax

        // Change the texture scale when we're viewing top down to reduce the
        // tiling and make it look better.
        if PlayerUI_IsOverhead() then
            Client.SetRenderSetting("infestation_scale", 0.15)
        else
            Client.SetRenderSetting("infestation_scale", 0.30)
        end

    end

end

